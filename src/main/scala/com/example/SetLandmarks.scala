package com.example
import java.awt.Color
import scala.math.{acos, Pi}
import scalismo.common._
import scalismo.utils.Random.implicits._
import scalismo.io.{LandmarkIO, MeshIO, StatismoIO}
import java.io.File
import java.io._

import scalismo.common.PointWithId
import scalismo.mesh.TriangleMesh
import scalismo.geometry.{Landmark, Point, Point3D}
import scalismo.geometry._3D
import scalismo.ui.api.{ScalismoUI, StatisticalMeshModelViewControls}
import spire.random
import scalismo.{geometry, mesh}

import scala.collection.mutable
import scala.collection.mutable.ListBuffer
import scala.util
import scala.util.Random


class SetLandmarks (meshToLandmark : TriangleMesh[_3D] ) {
  // read a model from statistical shape model
  val scapM = StatismoIO.readStatismoMeshModel(new File("C:/Users/la  cage/Downloads/scapulaPCAmodel.h5")).get
  // take the mean mesh as reference
  val meanRefMesh = scapM.mean

  /* We now load the landmarks, take the closest point on our mean mesh
     We save those points ids, to use the correspondence to get the landmarks
     on the new mesh that we sampled (meshToLandmark
   */
  val scapLandmarks = LandmarkIO.readLandmarksJson[_3D](new File("C:/Users/la  cage/Documents/firstTryScap.json")).get
  val setPoint = meanRefMesh.pointSet
  val seqPtsLM = Seq[PointId](setPoint.findClosestPoint(scapLandmarks(0).point).id,
    setPoint.findClosestPoint(scapLandmarks(1).point).id, setPoint.findClosestPoint(scapLandmarks(2).point).id,
    setPoint.findClosestPoint(scapLandmarks(3).point).id, setPoint.findClosestPoint(scapLandmarks(4).point).id,
    setPoint.findClosestPoint(scapLandmarks(5).point).id, setPoint.findClosestPoint(scapLandmarks(6).point).id,
    setPoint.findClosestPoint(scapLandmarks(7).point).id, setPoint.findClosestPoint(scapLandmarks(8).point).id,
    setPoint.findClosestPoint(scapLandmarks(9).point).id, setPoint.findClosestPoint(scapLandmarks(10).point).id,
    setPoint.findClosestPoint(scapLandmarks(11).point).id, setPoint.findClosestPoint(scapLandmarks(12).point).id)


  /* This method gives us a ListBuffer containing all the Landmarks that we need on a new sampled mesh
   */
  def strategicLandmarks() : mutable.ListBuffer[Landmark[_3D]] = {
    val newsetPoint = meshToLandmark.pointSet
    var newLM = mutable.ListBuffer[Landmark[_3D]](Landmark("GL", newsetPoint.point(seqPtsLM(0))), Landmark("GR", newsetPoint.point(seqPtsLM(1))),
      Landmark("AI", newsetPoint.point(seqPtsLM(2))), Landmark("PC", newsetPoint.point(seqPtsLM(3))),
      Landmark("GS", newsetPoint.point(seqPtsLM(4))), Landmark("GI", newsetPoint.point(seqPtsLM(5))),
      Landmark("AA", newsetPoint.point(seqPtsLM(6))), Landmark("MAA", newsetPoint.point(seqPtsLM(7))),
      Landmark("LAA", newsetPoint.point(seqPtsLM(8))),Landmark("PA", newsetPoint.point(seqPtsLM(9))),
      Landmark("TS", newsetPoint.point(seqPtsLM(10))),Landmark("SA", newsetPoint.point(seqPtsLM(11))),
      Landmark("GC", newsetPoint.point(seqPtsLM(12))))
    return newLM}


  /* This method gives us the coordinates of the particular Landmark we want as a vector
     Argument : String ("AA")
     Return : Vector[_3D] (223, 45, 8)
  */
  def coordinatesOf(name : String): geometry.Vector[_3D] ={
    var strLandmarks = this.strategicLandmarks()
    var pointToVectorize = new Point3D(0, 0, 0)
    for (landmark <- strLandmarks) {
      if (landmark.id == name) {
        pointToVectorize = landmark.point}
      }
   return pointToVectorize.toVector}

  /* This method gives us the tilt of the glene on our new sampled mesh
  Jonathan Matlab Code :
      v_GCTS = (GC - TS)/norm(GC - TS); % direction vector between the glenoid fossa centre and the scapular spine
      v_TSAI = (TS - AI)/norm(TS - AI); % direction vector between the scapular spine and inferior angle

      n_TiltPlane =  cross(v_GCTS,v_TSAI)/norm(cross(v_GCTS,v_TSAI)); % normal of the plane generated by v_GCTS and v_TSAI

      % Superior Glenoid projected into the Tilt Plane:
      GFSp = GF_S - dot(GF_S-GC,n_TiltPlane)*n_TiltPlane;

      % Inferior Glenoid projected into the Tilt Plane:
      GFIp = GF_I - dot(GF_I-GC,n_TiltPlane)*n_TiltPlane;

      v3 = (GFSp - GFIp)/norm(GFSp - GFIp); % Direction vector between the in-plane superior and inferior borders of the glenoid fossa

      Tilt = acosd(dot(v_GCTS,v3)); % dot product to calculate Tilt Angle (in degrees)
      % NB: Check for Superior or Inferior Inclination
   */
  def tilt(): Double ={
    val GC = this.coordinatesOf("GC")
    val TS = this.coordinatesOf("TS")
    val AI = this.coordinatesOf("AI")
    val GS = this.coordinatesOf("GS")
    val GI = this.coordinatesOf("GI")

    val vectorGC_TS = (GC.-(TS))./(GC.-(TS).norm) // direction vector between the glenoid fossa centre and the scapular spine
    val vectorTS_AI = (TS.-(AI))./(TS.-(AI).norm) // direction vector between the scapular spine and inferior angle

    val n_TiltPlane = vectorGC_TS.crossproduct(vectorTS_AI)./( vectorGC_TS.crossproduct(vectorTS_AI).norm) // normal of the plane generated by vectorGC_TS and vectorTS_AI

    // Superior Glenoid projected into the Tilt Plane:
    val GS_tp = GS.-(n_TiltPlane.*((GS.-(GC)).dot(n_TiltPlane)))

    // Inferior Glenoid projected into the Tilt Plane:
    val GI_tp = GI.-(n_TiltPlane.*((GI.-(GC)).dot(n_TiltPlane)))

    val v3 = (GS_tp.-(GI_tp))./((GS_tp.-(GI_tp)).norm) // Direction vector between the in-plane superior and inferior borders of the glenoid fossa
    val tilt = (acos(vectorGC_TS.dot(v3)).*(180)./(Pi)).-(90)
    return tilt}


  /* This method gives us the version of the glene on our new sampled mesh
    Jonathan Matlab Code :
     n_VersionPlane =  cross(v_GCTS,n_TiltPlane)/norm(cross(v_GCTS,n_TiltPlane)); % normal of the plane perpendicular to the Tilt Plane (i.e. the Version Plane)

     % Anterior Glenoid projected into the Version Plane:
     GFAp = GF_A - dot(GF_A-GC,n_VersionPlane)*n_VersionPlane;

     % Posterior Glenoid projected into the Version Plane:
     GFPp = GF_P - dot(GF_P-GC,n_VersionPlane)*n_VersionPlane;

     v4 = (GFAp - GFPp)/norm(GFAp - GFPp); % Direction vector between the in-plane anterior and posterior borders of the glenoid fossa

     Version = acosd(dot(v_GCTS,v4)); % dot product to calculate Version Angle (in degrees)
     % NB: Check for Retroversion or Anteversion (Friedman et al. 1992)
   */
  def version(): Double ={
    val GC = this.coordinatesOf("GC")
    val TS = this.coordinatesOf("TS")
    val AI = this.coordinatesOf("AI")
    val GS = this.coordinatesOf("GS")
    val GI = this.coordinatesOf("GI")
    val GA = this.coordinatesOf("GA")
    val GP = this.coordinatesOf("GP")

    val vectorGC_TS = (GC.-(TS))./(GC.-(TS).norm) // direction vector between the glenoid fossa centre and the scapular spine
    val vectorTS_AI = (TS.-(AI))./(TS.-(AI).norm) // direction vector between the scapular spine and inferior angle

    val n_TiltPlane = vectorGC_TS.crossproduct(vectorTS_AI)./( vectorGC_TS.crossproduct(vectorTS_AI).norm) // normal of the plane generated by vectorGC_TS and vectorTS_AI
    val n_versionPlane =  vectorGC_TS.crossproduct(n_TiltPlane)./( vectorGC_TS.crossproduct(n_TiltPlane).norm) // normal of the plane perpendicular to the Tilt Plane (i.e. the Version Plane)

    // Anterior Glenoid projected into the  Plane:
    val GA_vp = GA.-(n_versionPlane.*((GA.-(GC)).dot(n_versionPlane)))

    // Posterior Glenoid projected into the Tilt Plane:
    val GP_vp = GI.-(n_versionPlane.*((GP.-(GC)).dot(n_versionPlane)))

    val v3 = (GA_vp.-(GP_vp))./((GA_vp.-(GP_vp)).norm) // Direction vector between the in-plane anterior and posterior borders of the glenoid fossa

    val version = (acos(vectorGC_TS.dot(v3)).*(180)./(Pi)).-(90)
    return version}

  /* This method gives us the inclination of the glene on our new sampled mesh
      Implement by myself
   */
  def inclination(): Unit ={

  }

  /* This method gives us the critical shoulder angle on our new sampled mesh
   Jonathan Matlab Code :
     AA=input1(1).Points; % 3D co-ordinates: lateral point of the acromial angle
     GF_S=input2(1).Points; % 3D co-ordinates: superior glenoid fossa border
     GF_I =input3(1).Points; % 3D co-ordinates: inferior glenoid fossa border

     v_AAI = (AA - GF_I)/norm(AA - GF_I); % direction vector between the inferior edge of the glenoid fossa and the lateral AA
     v_SI = (GF_S - GF_I)/norm(GF_S - GF_I); % direction vector between the superior and inferior edges of the glenoid fossa

     n_plane = cross(v_AAI,v_SI)/norm(cross(v_AAI,v_SI)); % normal of the plane generated by the direction vectors

     CSA = acosd(dot(v_AAI,v_SI)); % dot product of the direction vectors to calculate critical shoulder angle (in degrees)
   */
  def criticalShouAng(): Double ={
    val AA = this.coordinatesOf("AA")
    val GF_S = this.coordinatesOf("GS")
    val GF_I = this.coordinatesOf("GI")

    val vectorAA_GF_I = AA.-(GF_I)./(AA.-(GF_I).norm) // direction vector between the inferior edge of the glenoid fossa and the lateral AA
    val vectorGF_S_GF_I = GF_S.-(GF_I)./(GF_S.-(GF_I).norm) // direction vector between the superior and inferior edges of the glenoid fossa
    val CSA = acos(vectorAA_GF_I.dot(vectorGF_S_GF_I)).*(180)./(Pi)
    return CSA}



  /* This method gives us the glenoid widthon our new sampled mesh
   */
  def glenoidWidth(): Double = {
    val GA = this.coordinatesOf("GA")
    val GP = this.coordinatesOf("GP")

    val width = GA.-(GP).norm
    return width}



  /*This method gives us the glenoid length on our new sampled mesh
   */
  def glenoidLength(): Double = {
    val GS = this.coordinatesOf("GS")
    val GI = this.coordinatesOf("GI")

    val length = GS.-(GI).norm
    return length}



  /*Method that returns an array containing csa, version, tilt, width and length
   */
  def practicalMethod(): Array[Double] = {
    val infoArray = Array(this.criticalShouAng(), this.version(), this.tilt(), this.glenoidWidth(), this.glenoidLength())
    return infoArray}


  /*This method gives us the Acromion shape on our new sampled mesh
    Return : ( Int ) 1 (C is on the line A-B) 2 (type I OA = OC), 3 (type 2 OA<OC)
   */
  def acromionShape() : Int = {
    //We define a threshold to consider whether or not OA=OC and C is on the line
    val thresh = 0.5 // 0.5 millimeters
    val AA = this.coordinatesOf("AA")
    val MAA = this.coordinatesOf("MAA")
    val LAA = this.coordinatesOf("LAA")
    val GC = this.coordinatesOf("GC")

    // We can now compute the distance OA between GC and AA and OC between
    // GC and MAA
    val distOA = GC.-(AA).norm
    val distOC = GC.-(MAA).norm
    return 1
  }
}
